var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站:\xa0 https://mdecd2025.github.io/hw-41223242 \n 學員作業倉儲:\xa0 https://github.com/mdecd2025/hw-41223242 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n', 'tags': '', 'url': 'About.html'}, {'title': 'repo', 'text': '\n', 'tags': '', 'url': 'repo.html'}, {'title': 'Task', 'text': '\n', 'tags': '', 'url': 'Task.html'}, {'title': 'task1', 'text': '修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat,關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具 \n \n \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'task2', 'text': '', 'tags': '', 'url': 'task2.html'}, {'title': 'List', 'text': 'G2 list \n \n', 'tags': '', 'url': 'List.html'}, {'title': 'task3', 'text': '\n \n \n \n \n \n', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': '', 'tags': '', 'url': 'task4.html'}, {'title': 'W4', 'text': 'webots練習四連桿操作後的最終結果 \n \n \n \n \n', 'tags': '', 'url': 'W4.html'}, {'title': 'w6', 'text': '\n', 'tags': '', 'url': 'w6.html'}, {'title': 'task5', 'text': '', 'tags': '', 'url': 'task5.html'}, {'title': 'w7', 'text': '\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'task6', 'text': '\n \n \n \n \n \n \n', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號 \n \n webots fourbar.7z \n fourbar_controller.7z \n fourbar1.zip \n 在進行操作練習時遇到多次問題，當無法自行解決時，我透過詢問 ChatGPT 並參考同學的操作影片，逐步修正錯誤，最終順利完成操作。 \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n fourbar2.zip \n \n HW2的內容操作與HW1的操作是差不多的，不同的地方在於要先將零件用solvespace繪製，再將零件進行組裝存成stl，stl轉成obj，開啟webots將零件一個一個加入進webots中，但整體操作起來是比HW1簡單一點。 \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號 \n \n \n 在製作的過程中因一直在模擬時發生問題，所以將floor(地板）和外牆與籃球框移除重新製作（重新製作的過程影片於影片中的39:26開始） \n \n basketball.zip \n \n HW3的做法與HW2的做法類似，都是先在solvespace 把零件繪製完成，再將組合後的零件存成stl，將stl的檔案轉換成obj 後，開啟webots 建立Robot，在Robot下加入solid(base)和兩個hingejoint ，剩下的做法與HW2相似加入零件與修改內部數值，不一樣的地方在於需要多加ball與籃球框和地板，我覺得在整體的實際操作上比HW2還要難上一點，花了蠻多的時間才成功做出來。 \n \n \n \n \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '本課程所繳交的期中成績為學員自評之學習期望成績. \n 期中考週的自評期望成績繳交流程: \n \n 整理先前所完成的各週的進度、作業網頁內容以及心得 \n 拍攝期中自評影片, 上傳至 Youtube 後, 以" 國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號 "為影片標題後嵌入本頁面中 \n 回填期中自評表單 \n 上傳學員期中成績 \n \n 各週進度: python313、小組名單list、四連桿繪製、投籃機繪製 \n 各週網頁內容: python 313 、 List 、 四連桿 、 投籃機 \n 期中心得:我覺得在這學期學的內容比較困難，在進度都落後老師教的，需要花更多的時間多加練習，尤其是在webots要更努力。 \n 期中自評影片: \n \n \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號 \n \n \n 1.先加入Robot 2.在Robot下的children 加入Solid（名稱改為base)再加入兩個HingeJoint(一個名稱改為joint1另一個名稱改為joint4) 3.在base下的children加入Shape 4.在Shape下的geometry加入Box大小為1、0.1、0.1、appearance下修改顏色（先暫時用成白色） 5.在joint1下的endPoint加入Solid（並改名為link1) 6.在Solid下的children加入Pose 7.在Pose下的children加入Shape 8.在Shape下的geometry加入Box大小為0.4、0.1、0.1、appearance下修改顏色，顏色改為紅色 9.在Pose下的translation更改數值0.2、0、0 10.在Solid下的translation更改數值-0.5、0、0.1 11.修改Solid(link1)下的rotation (學號後兩碼42，42degree=0.73303829rad) 12.在Solid(link1)下的bounding加入Pose，在children下加入Box，修改尺寸0.4、0.1、0.1，並修改translation 0.2、0、0 13.開啟physics 14.在Solid(link1)下的children加入HingeJoint(與Pose同一階)，並改名為joint2 15.在joint1下的endPoint加入Solid（並改名為link2) 16.在Solid下的children加入兩個Pose 17.在Pose下的children加入Shape 18.在Shape下的geometry加入Box大小為0.6、0.1、0.1、appearance下修改顏色，顏色改為綠色 19.在Pose下的translation更改數值0.3、0、0 20.在Pose下的children加入Shape 21.在Shape下的geometry加入Box大小為0.1、0.3、0.1、appearance下修改顏色，顏色改為綠色，並更改Pose下的translation0.3，0.15，0 22.在Solid下的translation更改數值0.4、0、0.1 23.修改Solid(link2)下的rotation (由solvespace繪圖，推算出角度為160.2，180-160.2=19.8，19.8degree=0.34557519rad) 24.在Solid(link2)下的bounding加入Pose，在children下加入Box，修改尺寸0.6、0.1、0.1，並修改translation 0.3、0、0 25.開啟physics 26.在Solid(link2)下的children加入HingeJoint(與Pose同一階)，並改名為joint3 27.在joint3下的endPoint加入Solid（並改名為link3) 28.在Solid下的children加入Pose 29.在Pose下的children加入Shape 30.在Shape下的geometry加入Box大小為0.9、0.1、0.1、appearance下修改顏色，顏色改為藍色 31.在Pose下的translation更改數值0.45、0、0 32.在Solid下的translation更改數值0.6、0、-0.1 33.修改Solid(link3)下的rotation (由solvespace繪圖，推算出角度為55.94，180-55.96=124.04，124.04degree=2.1649064rad) 34.在Solid(link3)下的bounding加入Pose，在children下加入Box，修改尺寸0.9、0.1、0.1，並修改translation 0.45、0、0 35.開啟physics 36.在joint1下的jointParameters加入HingeJointParameters，修改axis0、0、1，修改anchor-0.5、0、0 37.在joint1下的device加入RotationalMotor，並將name改成motor 38.在joint2下的jointParameters加入HingeJointParameters，修改axis0、0、1，修改anchor0.4、0、0 39.在joint3下的jointParameters加入HingeJointParameters，修改axis0、0、1，修改anchor0.6、0、0 40.在joint4下的endPoint加入SolidReference，並選擇link3 41.在joint4下的jointParameters加入HingeJointParameters，修改axis0、0、1，修改anchor0.5、0、0 42.到Robot下的controller選擇fourbar controller 43將base改成透明 44.按下開始 45.完成 \n \n exam1在整體的操作上與HW1是差不多的，建立box與修改顏色、內部的數值，只有在link2的部分圖形是不一樣的，另外還要注意紅色桿（link1）的起始角度要設定為學號後兩碼，另外在base的部分需要將base隱藏，整體的難度我覺得適中。 \n \n \n exam1.zip \n \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號 \n \n 1.先利用solvespace 繪製出四邊形，link1為142（42為學號後兩碼）、link2為180、link3為200、兩base的距離為220，並繪製起始角度為42度 2.分別繪製base1、base2、link1、link2、link3 3.將零件進行組合（存成stl） 4.把組合後的stl 利用程式轉換成obj 順便將單位轉換 5.開啟webots  6.新增Robot 7.在Robot新增base1、base2、joint1、joint4 8.利用CadShape分別將所需的零件匯入webots  9.joint2需要建立在joint1下 10.joint3需要建立在joint2下 11.在joint1下建立馬達 12.joint1 joint2 joint3下的boundingObject 新增Mesh並選擇零件 13.開啟physics  14.利用solvespace量測出接點的xy 距離輸入進anchor （joint2的x =1.05 y =0.95、joint3的x =2.53 y =1.97 15.joint4下的solidReference 選擇link3 16.更改joint4下的anchor為2.2、0、0 17.將每個axis變更為0、0、1 18.robot下的controller選擇fourbar \n 影片44:24後為重新繪製零件圖，因為發現link2的圖形繪製錯誤，所以重新繪製與轉檔，開啟製作完成的exam2的webots 檔案，因該修改的參數都已經修改完成，所以只要將原本的零件檔案變更成新繪製的零件檔案就完成了 \n \n exam2的操作與HW2的操作是差不多的，都是先將零件的外型尺寸利用solvespace繪製，再將其組裝，組裝完成後存成stl 利用程式將檔案轉換成obj ，開啟webots 新增base1 base2 joint1 joint4，修改其內部的數值，joint2新增在joint1下，joint3新增在joint2下，把相對應的零件匯入至對應的位置。其中我在轉換檔案時，沒有注意到我把程式內檔案名稱後面的stl 刪除了，導致一直無法轉換檔案，看了幾次後終於發現問題，也順利的解決了。 \n exam2.zip \n \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n \n 1.先到 https://mde.tw/cd2025/content/IPv6.html 下的 https://mde.tw/cd2025/downloads/w4_2b_index.txt 找到自己的ipv6 \n 2.打開控制台 \n 3.點選網路和共用中心 \n 4.乙太網路 \n 5.內容更改ipv6 \n 6. 打開cmd 打入 webot --stream\xa0 "檔案路徑\\檔名.wbt \n 7. 打開webots後，用瀏覽器開啟此連結 http://localhost:1234/index.html \n 8. 按connect確認是否有與webots連上 \n 9. 將原本上面的ws://localhost:1234改成ws://[自己的ipv6]:1234 \n 10.有跑出webots的畫面代表成功 \n \n \n 心得 \n 剛開始看到Exam3的內容文字敘述時，我不知道該如何操作，後面請教同學經過同學的解說與教導，才懂得如何操作，整體就是卡在不知如何串流，就是在串流部分卡比較久。 \n \n Exam3-1 \n \n \n \n \n Exam3-2 \n \n \n \n Exam3-3 \n \n \n 下面影片為3部影片的合輯 \n \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:  Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題 \n \n \n 投籃機的製作 \n \n \n 籃球框的製作 \n \n 因原本的投籃機和籃框尺寸太大，所以更換為小尺寸的 投籃機和籃框 \n \n \n 利用前後左右控制投籃機的位置，按下A產生一顆球，按下M把球擊出，按K使投籃機恢復。 \n \n \n \n \n Final1.7z \n 期末報告 \n \n Final.7z (最終的完成檔案) \n \n \n \n 在這個學期使用webots 來製作與模擬，要學習一個新的事物並非想像中的輕鬆，在練習的過程中也是遇到了許多的困難，從一開始最基本的四連桿模擬，到後來的投籃機的製作，都是一步一步慢慢練習學習才有的結果，在使用webots 時，一旦有出現一個錯誤的設定的地方或是沒有設定到的地方就沒辦法進行模擬，常常就一直在裡面找哪裡設定錯誤，很多的設定都是有前後關係的，花了蠻多的時間在除錯，在這堂課中，讓我學到了很多，要不斷的去認識新事物不能一直安於現狀，雖然學習新事物不是很簡單的事情，但只要有耐心都是可以學會的只是要花較長的時間。', 'tags': '', 'url': 'Final.html'}, {'title': '程式', 'text': '', 'tags': '', 'url': '程式.html'}, {'title': '投籃機和車', 'text': 'from controller import Robot, Keyboard\n\n# === 常數設定 ===\nTIME_STEP = 32                             # 每個模擬時間步長（毫秒）\nMAX_VELOCITY = 10.0                        # 輪子的最大速度\nANGLE_STEP = 40 * 3.14159 / 180            # 將40度轉換成弧度，約 0.698 rad\nPOSITION_M = ANGLE_STEP                    # 馬達轉到 +40 度的位置\nPOSITION_K = 0.0                           # 馬達轉回 0 度的位置\n\n# === 初始化機器人與鍵盤 ===\nrobot = Robot()                            # 建立 Webots 中的機器人實例\ntimestep = int(robot.getBasicTimeStep())   # 取得 Webots 建議的時間步長\nkeyboard = Keyboard()                      # 建立鍵盤控制器\nkeyboard.enable(timestep)                  # 啟用鍵盤控制\n\n# === 嘗試取得馬達與感測器 ===\ntry:\n    motor = robot.getDevice(\'motor1\')         # 取得名為 \'motor1\' 的馬達\n    sensor = robot.getDevice(\'motor1_sensor\') # 取得馬達的位置感測器\n    sensor.enable(timestep)                   # 啟用感測器\n    mechanism_enabled = True                  # 設定馬達控制可用\nexcept Exception:\n    mechanism_enabled = False                 # 若找不到裝置，關閉功能\n\n# === 嘗試取得四個輪子 ===\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]  # 取得 \'wheel1\'~\'wheel4\'\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))       # 設為無限位置，啟用速度控制模式\n        wheel.setVelocity(0)                  # 一開始速度設為0\n    platform_enabled = True                   # 啟用平台移動功能\nexcept Exception:\n    platform_enabled = False                  # 找不到輪子就關閉平台功能\n\n# === 狀態與按鍵觸發狀態控制 ===\ncurrent_state = "allow_m"                     # 初始狀態允許按下 \'m\'\nkey_pressed = {                               # 用來防止長按重複觸發\n    \'k\': False,\n    \'m\': False\n}\n\n# === 主控制迴圈 ===\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()  # 取得當前鍵盤按鍵（ASCII碼或方向鍵常數）\n\n    # === 平台移動控制 ===\n    if platform_enabled:\n        if key == Keyboard.UP:\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)  # 所有輪子向前\n        elif key == Keyboard.DOWN:\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY) # 所有輪子向後\n        elif key == Keyboard.LEFT:\n            # 左轉：左右輪相反轉\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            # 右轉：左右輪相反轉\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            print("Exiting...")\n            break  # 按下 Q 鍵跳出迴圈結束模擬\n        else:\n            for wheel in wheels:\n                wheel.setVelocity(0)  # 沒按方向鍵就停止\n\n    # === 馬達控制（M / K 鍵切換） ===\n    if mechanism_enabled:\n        _current_motor_position = sensor.getValue()  # 可用於偵錯但此程式沒用上\n\n        # 按下 M：轉到 +40 度\n        if key == ord(\'M\') or key == ord(\'m\'):\n            if not key_pressed[\'m\'] and current_state == "allow_m":\n                motor.setPosition(POSITION_M)       # 馬達設定目標位置\n                current_state = "allow_k"           # 下一次只能按 k\n            key_pressed[\'m\'] = True\n        else:\n            key_pressed[\'m\'] = False                # 沒按時重設按鍵狀態\n\n        # 按下 K：轉回 0 度\n        if key == ord(\'K\') or key == ord(\'k\'):\n            if not key_pressed[\'k\'] and current_state == "allow_k":\n                motor.setPosition(POSITION_K)\n                current_state = "allow_m"           # 下一次允許按 m\n            key_pressed[\'k\'] = True\n        else:\n            key_pressed[\'k\'] = False\n \n', 'tags': '', 'url': '投籃機和車.html'}, {'title': 'supervisor Robots', 'text': 'from controller import Supervisor, Keyboard\nimport time\nimport random\nimport numpy as np\nimport re\n\n# ----------------- 基本參數區 -----------------\nHOOP_CENTER = [0.622, -0.103, 0.742838]        # 籃框中心座標（可用於擴充得分偵測）\nBALL_DEF_PATTERN = re.compile(r"Sphere_\\d+")  # 用來匹配球的 DEF 名稱\n\nsupervisor = Supervisor()                     # 建立 Supervisor\ntimestep = int(supervisor.getBasicTimeStep()) # 模擬步長\nkeyboard = Keyboard()                         # 鍵盤控制器\nkeyboard.enable(timestep)\n\n# 球與軌跡點設定\nsphere_radius = 0.1\nTRAJECTORY_POINT_RADIUS = 0.03\nTRAJECTORY_POINT_STEP = 0.12\nTRAJECTORY_MAX_POINTS = 5                     # 最多5個軌跡點\n\n# 追蹤狀態參數\nwaiting_ball_def = None\nwaiting_ball_info = None\ncurrent_tracked_def = None\ntrajectory_points = []\n\n# 時間與按鍵防抖設定\nlast_key_time = 0\ndebounce_time = 0.5\ndefault_feed_pos = (-0.35, 0.0, 0.9)           # youbot 前方球起始點\nlast_print_time = time.time()\nPRINT_INTERVAL = 0.2\n\n# ----------------- 輔助函式區 -----------------\n\n# 轉換 youbot 的局部座標為世界座標\ndef axis_angle_to_rotation_matrix(axis, angle):\n    x, y, z = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    C = 1 - c\n    return np.array([\n        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n    ])\n\ndef youbot_local_to_world(local_pos):\n    youbot_node = supervisor.getFromDef(\'youbot\')\n    if youbot_node is None:\n        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n    youbot_translation = np.array(youbot_node.getField(\'translation\').getSFVec3f())\n    youbot_rotation = youbot_node.getField(\'rotation\').getSFRotation()\n    youbot_axis = youbot_rotation[:3]\n    youbot_angle = youbot_rotation[3]\n    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)\n    rotated = youbot_rot_mat @ np.array(local_pos)\n    world_pos = youbot_translation + rotated\n    return tuple(world_pos)\n\n# 隨機產生不重複的 DEF 名稱\ndef generate_valid_def_name(base_name="Sphere"):\n    timestamp = int(supervisor.getTime() * 1000)\n    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n\n# 隨機顏色\ndef generate_random_color():\n    return random.random(), random.random(), random.random()\n\n# ----------------- 球與軌跡點建立 -----------------\n\ndef create_static_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n    }}\n    """\n    supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_string)\n\ndef create_dynamic_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n      physics Physics {{\n        mass 0.01\n        density -1\n      }}\n    }}\n    """\n    supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_string)\n\ndef create_trajectory_point(pos):\n    def_name = generate_valid_def_name("TrajectoryPt")\n    sphere_string = f"""\n    DEF {def_name} Transform {{\n      translation {pos[0]} {pos[1]} {pos[2]}\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {TRAJECTORY_POINT_RADIUS}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor 1 0.7 0\n              transparency 0.3\n            }}\n          }}\n        }}\n      ]\n    }}\n    """\n    supervisor.getRoot().getField("children").importMFNodeFromString(-1, sphere_string)\n    return def_name\n\ndef delete_trajectory_points():\n    global trajectory_points\n    for _, def_name in trajectory_points:\n        node = supervisor.getFromDef(def_name)\n        if node:\n            node.remove()\n    trajectory_points.clear()\n\n# ----------------- 控制球生成與擊出 -----------------\n\ndef create_static_sphere(supervisor, x, y, z):\n    global waiting_ball_def, waiting_ball_info\n    def_name = generate_valid_def_name()\n    waiting_ball_def = def_name\n    r, g, b = generate_random_color()\n    world_pos = youbot_local_to_world((x, y, z))\n    waiting_ball_info = (world_pos, r, g, b)\n    create_static_ball(def_name, world_pos, r, g, b)\n\ndef activate_dynamic_ball():\n    global waiting_ball_def, waiting_ball_info\n    if waiting_ball_def is None or waiting_ball_info is None:\n        return\n    ball_node = supervisor.getFromDef(waiting_ball_def)\n    if ball_node is not None:\n        ball_node.remove()\n        supervisor.step(int(supervisor.getBasicTimeStep()))\n    world_pos, r, g, b = waiting_ball_info\n    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)\n    waiting_ball_def = None\n    waiting_ball_info = None\n\ndef is_ball_landed(pos, threshold_z=0.13):\n    return pos[2] < threshold_z\n\n# ----------------- 主控制流程 -----------------\n\nprint("按 A 產生一顆靜止球，按 M 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")\n\nwhile supervisor.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n\n    # 產生靜止球\n    if key == ord(\'A\') and (current_time - last_key_time >= debounce_time):\n        if waiting_ball_def is None:\n            create_static_sphere(supervisor, *default_feed_pos)\n            current_tracked_def = waiting_ball_def\n            delete_trajectory_points()\n        else:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n        last_key_time = current_time\n\n    # 擊球（轉為動態）\n    if key == ord(\'M\') and (current_time - last_key_time >= debounce_time):\n        activate_dynamic_ball()\n        last_key_time = current_time\n\n    # 拋物線追蹤與軌跡點\n    if current_tracked_def is not None:\n        ball_node = supervisor.getFromDef(current_tracked_def)\n        if ball_node is not None:\n            pos = ball_node.getPosition()\n            if current_time - last_print_time >= PRINT_INTERVAL:\n                last_print_time = current_time\n            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) > TRAJECTORY_POINT_STEP:\n                def_name = create_trajectory_point(pos)\n                trajectory_points.append((pos, def_name))\n                if len(trajectory_points) > TRAJECTORY_MAX_POINTS:\n                    _, old_def = trajectory_points.pop(0)\n                    node = supervisor.getFromDef(old_def)\n                    if node:\n                        node.remove()\n            if is_ball_landed(pos):\n                delete_trajectory_points()\n        else:\n            delete_trajectory_points()\n            current_tracked_def = None\n \n \n \n \n 按A產生一顆新球，按M把球擊出。', 'tags': '', 'url': 'supervisor Robots.html'}, {'title': 'stand youbots', 'text': '\n from controller import Robot, Keyboard\n\n# === 機器人設定參數 ===\nWHEEL_RADIUS = 0.1  # 輪子半徑 (單位: 公尺)\nL = 0.471           # 機器人長度一半\nW = 0.376           # 機器人寬度一半\nMAX_VELOCITY = 10.0 # 最大輪速\n\n# === 初始化機器人與裝置 ===\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\n\n# 得分發射器\nemitter = robot.getDevice("score_emitter")\nscore_to_send = 2  # 每次得分傳送的分數\n\n# 紅外線距離感測器\nsensor = robot.getDevice(\'sensor\')\nsensor.enable(timestep)\n\n# 鍵盤初始化\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\n# 四顆輪子（以機器人右前、左前、右後、左後順序）\nwheel5 = robot.getDevice("wheel5")\nwheel6 = robot.getDevice("wheel6")\nwheel7 = robot.getDevice("wheel7")\nwheel8 = robot.getDevice("wheel8")\n\nfor wheel in [wheel5, wheel6, wheel7, wheel8]:\n    wheel.setPosition(float(\'inf\'))  # 啟用速度控制模式\n    wheel.setVelocity(0)\n\n# 設定輪速函式\ndef set_wheel_velocity(v1, v2, v3, v4):\n    wheel5.setVelocity(v1)\n    wheel6.setVelocity(v2)\n    wheel7.setVelocity(v3)\n    wheel8.setVelocity(v4)\n\n# === 紅外線感測 AD值對應距離表 ===\nlookup_table = [\n    (1000, 0.00),\n    (620, 0.12),\n    (372, 0.13),\n    (248, 0.14),\n    (186, 0.15),\n    (0, 0.18)\n]\n\n# 根據 AD值做線性插值換算為距離\ndef ad_to_distance(ad_value):\n    for i in range(len(lookup_table)-1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i+1]\n        if a1 <= ad_value <= a0:\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    if ad_value > lookup_table[0][0]:\n        return lookup_table[0][1]\n    return lookup_table[-1][1]\n\n# === 主要狀態 ===\nscore = 0\nlast_score_time = 0\ncooldown = 1.0  # 每次得分之間的冷卻時間（秒）\n\n# === 說明提示 ===\nprint("Use \'E\', \'X\', \'S\', \'D\' keys to control the robot.")\nprint("E: Move forward, X: Move backward, S: Turn left, D: Turn right.")\nprint("Press \'Q\' to quit.")\n\n# === 主迴圈 ===\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()  # 讀取按鍵\n    sensor_value = sensor.getValue()\n    distance = ad_to_distance(sensor_value)\n    current_time = robot.getTime()\n\n    # 測試模式：按 M 或 K 可印出距離\n    if key == ord(\'M\') or key == ord(\'m\') or key == ord(\'K\') or key == ord(\'k\'):\n        print(distance)\n\n    # 得分偵測邏輯：當球進入一定距離範圍\n    if distance < 0.11 and (current_time - last_score_time) > cooldown:\n        score += score_to_send\n        print("得分")\n        print(distance)\n        emitter.send(str(score_to_send).encode(\'utf-8\'))  # 傳送得分訊息\n        last_score_time = current_time\n\n    # === 鍵盤操控 ===\n    if key == ord(\'E\') or key == ord(\'e\'):\n        set_wheel_velocity(MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY)  # 前進\n    elif key == ord(\'X\') or key == ord(\'x\'):\n        set_wheel_velocity(-MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY)  # 後退\n    elif key == ord(\'D\') or key == ord(\'d\'):\n        set_wheel_velocity(-MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY)  # 右轉\n    elif key == ord(\'S\') or key == ord(\'s\'):\n        set_wheel_velocity(MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY)  # 左轉\n    elif key == ord(\'Q\') or key == ord(\'q\'):\n        print("Exiting...")\n        break\n    else:\n        set_wheel_velocity(0, 0, 0, 0)  # 沒按鍵則停止\n \n E前進X後退S左D右', 'tags': '', 'url': 'stand youbots.html'}, {'title': 'counter supervisor', 'text': '\n from controller import Supervisor\n\n# === 七段顯示器段數定義：SEGMENTS[d] 表示數字 d 應該亮哪些段 ===\nSEGMENTS = [\n    [1,1,1,1,1,1,0], # 0：六段亮\n    [0,1,1,0,0,0,0], # 1\n    [1,1,0,1,1,0,1], # 2\n    [1,1,1,1,0,0,1], # 3\n    [0,1,1,0,0,1,1], # 4\n    [1,0,1,1,0,1,1], # 5\n    [1,0,1,1,1,1,1], # 6\n    [1,1,1,0,0,0,0], # 7\n    [1,1,1,1,1,1,1], # 8\n    [1,1,1,1,0,1,1], # 9\n]\n\n# === 三位數七段顯示器材質名稱對應（用 DEF 名稱尋找 Material node）===\n# 每一位的七段順序為：a~g\nDIGIT_MATERIALS = [\n    [\'a3mat\', \'b3mat\', \'c3mat\', \'d3mat\', \'e3mat\', \'f3mat\', \'g3mat\'], # 百位\n    [\'a2mat\', \'b2mat\', \'c2mat\', \'d2mat\', \'e2mat\', \'f2mat\', \'g2mat\'], # 十位\n    [\'a1mat\', \'b1mat\', \'c1mat\', \'d1mat\', \'e1mat\', \'f1mat\', \'g1mat\'], # 個位\n]\n\n# === 顯示顏色設定 ===\nON_COLOR = [0, 1, 0]          # 綠色（亮）\nOFF_COLOR = [0.05, 0.05, 0.05]# 暗色（關閉）\n\n# === 將某一位數設為指定數字 ===\ndef set_digit(supervisor, digit_index, value):\n    segs = SEGMENTS[value]  # 取得該數字需要亮的段\n    for i, seg_on in enumerate(segs):\n        mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])\n        if mat_node:\n            mat_node.getField(\'diffuseColor\').setSFColor(ON_COLOR if seg_on else OFF_COLOR)\n        else:\n            print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF")\n\n# === 將整個顯示器設定為三位數的數值（0~999）===\ndef set_display(supervisor, value):\n    value = max(0, min(999, int(value)))  # 限制範圍為0~999\n    h = value // 100                      # 百位數\n    t = (value // 10) % 10                # 十位數\n    u = value % 10                        # 個位數\n    set_digit(supervisor, 0, h)\n    set_digit(supervisor, 1, t)\n    set_digit(supervisor, 2, u)\n\n# === 初始化 Supervisor 與接收器 ===\nsupervisor = Supervisor()\ntimestep = int(supervisor.getBasicTimeStep())\n\nscore = 0  # 初始化得分\nreceiver = supervisor.getDevice("score_receiver")\nreceiver.enable(timestep)\n\n# === 主控制迴圈：每次模擬步驟都接收資料並更新顯示 ===\nwhile supervisor.step(timestep) != -1:\n    while receiver.getQueueLength() > 0:\n        data = receiver.getString()\n        if data.isdigit():  # 確認訊息是純數字\n            try:\n                received_score = int(data)\n                score += received_score\n                print(f"收到得分訊息: +{received_score}, 總分: {score}")\n            except Exception as e:\n                print("訊息格式錯誤:", e)\n        receiver.nextPacket()\n    set_display(supervisor, score)  # 更新顯示器\n \n', 'tags': '', 'url': 'counter supervisor.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};